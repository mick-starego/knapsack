/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/knapsack.js":
/*!*************************!*\
  !*** ./src/knapsack.js ***!
  \*************************/
/***/ (() => {

eval("{self.onmessage = function (event) {\n    let result;\n    try {\n        result = run(event.data.target, event.data.tax, event.data.itemList);\n    } catch (e) {\n        result = { error: e.message };\n    }\n    self.postMessage(result);\n};\n\nfunction run(target, tax, itemList) {\n    // Multiply prices by 100 to get integer value\n    // Sort items by price, i.e [78, 105, 199]\n    const calculatedItems = [...itemList]\n        .map((item) => ({ ...item, integerPrice: Math.round(item.unitPrice * 100) }))\n        .sort(((a, b) => a.integerPrice - b.integerPrice));\n\n    // Calculate the target value\n    //\n    // target = round(subtotal * (1 + tax), 2)\n    // ==> target - 0.005 = subtotal * (1 + tax)\n    //     subtotal >= (target - 0.005) / (1 + tax)\n    // ==> target + 0.005 = subtotal * (1 + tax)\n    //     subtotal < (target + 0.005) / (1 + tax)\n    const integerTarget = target * 100;\n    const rawTargetMin = (integerTarget - 0.5) / (1 + (tax / 100));\n    const rawTargetMax = (integerTarget + 0.5) / (1 + (tax / 100));\n\n    // Some combinations of target and tax are not solvable\n    if (Math.ceil(rawTargetMin) >= rawTargetMax) {\n        throw new Error(`Target ${target} is not possible for tax ${tax.toFixed(2)}%`);\n    }\n    const calculatedTarget = Math.ceil(rawTargetMin);\n\n    // Construct 2D array of data\n    //   - Rows represent number of items included [0, itemList.length]\n    //   - Cols represent total price [0, calculatedTarget]\n    //   - Entries (true/false) indicate whether it is possible\n    //     to make that specific price with the given items\n    const data = [];\n\n    // Populate the base case for 0 items\n    const baseCol = new Array(calculatedTarget + 1).fill(false);\n    baseCol[0] = true;\n    data.push(baseCol);\n\n    // Build array while progressively increasing item count\n    for (let row = 1; row <= calculatedItems.length; row++) {\n        const col = new Array(calculatedTarget + 1).fill(false);\n        for (let price = 0; price <= calculatedTarget; price++) {\n            // The item that wasn't included in the previous row\n            const newItem = calculatedItems[row - 1];\n\n            // Given price P, new item I, and number of new items N,\n            // check for (P - N * I.price) in the previous row to determine\n            // if the current combination of P, I and N is possible.\n            let newItemCount = 0;\n            while (newItemCount <= getNewItemCountMax(price, newItem.integerPrice)) {\n                const prevTarget = price - newItemCount * newItem.integerPrice;\n                if (data[row - 1][prevTarget]) {\n                    col[price] = true;\n                    break;\n                }\n                newItemCount++;\n            }\n        }\n        data.push(col);\n    }\n\n    // Check if solutions exist\n    const [lastRow, lastPrice] = [calculatedItems.length, calculatedTarget];\n    if (!data[lastRow][lastPrice]) {\n        // No solutions found!\n        return {\n            data: [],\n            numSolutions: 0\n        };\n    }\n\n    // Use DFS to read solutions\n    let topResults = [];\n    let numSolutions = 0;\n    const numResultsToKeep = 25;\n    const startTimeMs = Date.now();\n    const stack = [[lastRow, lastPrice, []]];\n    while (stack.length) {\n        const [row, price, path] = stack.pop();\n        const newItem = calculatedItems[row - 1];\n\n        // Solution found!\n        if (row === 0 && price === 0) {\n            const solution = buildSolution(path, calculatedItems, tax);\n            const score = getScore(solution, calculatedItems, calculatedTarget);\n            if (topResults.length < numResultsToKeep || score > topResults.at(-1).score) {\n                if (topResults.length >= numResultsToKeep) {\n                    topResults.pop();\n                }\n                topResults.push({ score, solution });\n                topResults.sort((a, b) => b.score - a.score);\n            }\n            numSolutions++;\n            continue;\n        }\n\n        // If we've been searching for longer than 10s, get out\n        // of here! If it's been 5s, pump the brakes to move it along.\n        const elapsedTimeMs = Date.now() - startTimeMs;\n        if (elapsedTimeMs > 10000) {\n            break;\n        } else if (elapsedTimeMs > 5000 && Math.random() < 0.2) {\n            continue;\n        }\n\n        // Push children onto stack\n        let newItemCount = 0;\n        while (newItemCount <= getNewItemCountMax(price, newItem.integerPrice)) {\n            const prevTarget = price - newItemCount * newItem.integerPrice;\n            if (data[row - 1][prevTarget]) {\n                stack.push([row - 1, prevTarget, [newItemCount, ...path]]);\n            }\n            newItemCount++;\n        }\n    }\n\n    return {\n        data: topResults,\n        numSolutions\n    };\n}\n\nfunction getNewItemCountMax(price, newItemPrice) {\n    return Math.floor(price / newItemPrice);\n}\n\nfunction buildSolution(path, calculatedItems, tax) {\n    // Construct item list from solutions\n    const solution = path\n        .map((quantity, i) => ({\n            ...calculatedItems[i],\n            quantity,\n            totalPrice: calculatedItems[i].unitPrice * quantity\n        }))\n        .filter((item) => item.quantity);\n\n    // Sort the result by category and price\n    solution.sort((a, b) =>\n        a.category === b.category\n            ? b.totalPrice - a.totalPrice\n            : a.category.localeCompare(b.category)\n    );\n\n    // Add tax and total\n    const subtotal = solution.reduce((prev, curr) => prev + curr.totalPrice, 0);\n    const totalTax = subtotal * tax / 100;\n    return [\n        ...solution,\n        {\n            name: 'Sales Tax ' + tax.toFixed(2) + '%',\n            totalPrice: totalTax\n        },\n        {\n            name: 'Total',\n            totalPrice: subtotal + totalTax\n        }\n    ];\n}\n\nfunction getScore(result, calculatedItems, calculatedTarget) {\n    // Filter out tax and total\n    const solutionItems = result.filter((item) => !!item.category);\n\n    // Diversity: Ratio of potential items included\n    const numUniqueItemsIncluded = solutionItems.length;\n    const totalUniqueItems = calculatedItems.length;\n    const diversityScore = numUniqueItemsIncluded / totalUniqueItems;\n\n    // Category utilization: Evenness of category representation\n    const categories = new Set(calculatedItems.map((item) => item.category));\n    const categoryItems = [...categories].map(\n        (category) => solutionItems.filter((item) => item.category === category)\n    );\n\n    // Utilization by price\n    const categoryPrices = categoryItems\n        .map((items) => items.reduce((prev, curr) => prev + curr.totalPrice, 0));\n    const minSubtotal = Math.min(...categoryPrices);\n    const maxSubtotal = Math.max(...categoryPrices);\n    const priceUtilizationScore = 1 - ((maxSubtotal - minSubtotal) / calculatedTarget);\n\n    // Utilization by count\n    const totalItems = solutionItems.reduce((prev, curr) => prev + curr.quantity, 0);\n    const categoryCounts = categoryItems\n        .map((items) => items.reduce((prev, curr) => prev + curr.quantity, 0));\n    const minSubCount = Math.min(...categoryCounts);\n    const maxSubCount = Math.max(...categoryCounts);\n    const countUtilizationScore = 1 - ((maxSubCount - minSubCount) / totalItems);\n\n    return (3 * diversityScore) + (2 * priceUtilizationScore) + countUtilizationScore;\n}\n\n//# sourceURL=webpack://knapsack/./src/knapsack.js?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/knapsack.js"]();
/******/ 	
/******/ })()
;